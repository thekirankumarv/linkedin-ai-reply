import { debounce } from "perfect-debounce";
import { getEntrypointBundlePath, isHtmlEntrypoint } from "./utils/entrypoints.mjs";
import {
  getContentScriptCssFiles,
  getContentScriptsCssMap
} from "./utils/manifest.mjs";
import {
  internalBuild,
  detectDevChanges,
  rebuild,
  findEntrypoints
} from "./utils/building/index.mjs";
import { createExtensionRunner } from "./runners/index.mjs";
import { Mutex } from "async-mutex";
import pc from "picocolors";
import { relative } from "node:path";
import { registerWxt, wxt } from "./wxt.mjs";
import { unnormalizePath } from "./utils/paths.mjs";
import {
  getContentScriptJs,
  mapWxtOptionsToRegisteredContentScript
} from "./utils/content-scripts.mjs";
export async function createServer(inlineConfig) {
  await registerWxt("serve", inlineConfig, async (config) => {
    const { port, hostname } = config.dev.server;
    const serverInfo = {
      port,
      hostname,
      origin: `http://${hostname}:${port}`
    };
    const server2 = {
      ...serverInfo,
      get watcher() {
        return builderServer.watcher;
      },
      get ws() {
        return builderServer.ws;
      },
      currentOutput: void 0,
      async start() {
        await builderServer.listen();
        wxt.logger.success(`Started dev server @ ${serverInfo.origin}`);
        await buildAndOpenBrowser();
      },
      async stop() {
        await runner.closeBrowser();
        await builderServer.close();
      },
      async restart() {
        await closeAndRecreateRunner();
        await buildAndOpenBrowser();
      },
      transformHtml(url, html, originalUrl) {
        return builderServer.transformHtml(url, html, originalUrl);
      },
      reloadContentScript(payload) {
        server2.ws.send("wxt:reload-content-script", payload);
      },
      reloadPage(path) {
        server2.ws.send("wxt:reload-page", path);
      },
      reloadExtension() {
        server2.ws.send("wxt:reload-extension");
      },
      async restartBrowser() {
        await closeAndRecreateRunner();
        await runner.openBrowser();
      }
    };
    return server2;
  });
  const server = wxt.server;
  let [runner, builderServer] = await Promise.all([
    createExtensionRunner(),
    wxt.builder.createServer(server)
  ]);
  const buildAndOpenBrowser = async () => {
    server.currentOutput = await internalBuild();
    try {
      server.watcher.add(getExternalOutputDependencies(server));
    } catch (err) {
      wxt.config.logger.warn("Failed to register additional file paths:", err);
    }
    await runner.openBrowser();
  };
  const closeAndRecreateRunner = async () => {
    await runner.closeBrowser();
    await wxt.reloadConfig();
    runner = await createExtensionRunner();
  };
  server.ws.on("wxt:background-initialized", () => {
    if (server.currentOutput == null) return;
    reloadContentScripts(server.currentOutput.steps, server);
  });
  const reloadOnChange = createFileReloader(server);
  server.watcher.on("all", reloadOnChange);
  return server;
}
function createFileReloader(server) {
  const fileChangedMutex = new Mutex();
  const changeQueue = [];
  const cb = async (event, path) => {
    changeQueue.push([event, path]);
    await fileChangedMutex.runExclusive(async () => {
      if (server.currentOutput == null) return;
      const fileChanges = changeQueue.splice(0, changeQueue.length).map(([_, file]) => file);
      if (fileChanges.length === 0) return;
      await wxt.reloadConfig();
      const changes = detectDevChanges(fileChanges, server.currentOutput);
      if (changes.type === "no-change") return;
      if (changes.type === "full-restart") {
        wxt.logger.info("Config changed, restarting server...");
        server.restart();
        return;
      }
      if (changes.type === "browser-restart") {
        wxt.logger.info("Runner config changed, restarting browser...");
        server.restartBrowser();
        return;
      }
      wxt.logger.info(
        `Changed: ${Array.from(new Set(fileChanges)).map((file) => pc.dim(relative(wxt.config.root, file))).join(", ")}`
      );
      const allEntrypoints = await findEntrypoints();
      try {
        const { output: newOutput } = await rebuild(
          allEntrypoints,
          // TODO: this excludes new entrypoints, so they're not built until the dev command is restarted
          changes.rebuildGroups,
          changes.cachedOutput
        );
        server.currentOutput = newOutput;
        switch (changes.type) {
          case "extension-reload":
            server.reloadExtension();
            wxt.logger.success(`Reloaded extension`);
            break;
          case "html-reload":
            const { reloadedNames } = reloadHtmlPages(
              changes.rebuildGroups,
              server
            );
            wxt.logger.success(`Reloaded: ${getFilenameList(reloadedNames)}`);
            break;
          case "content-script-reload":
            reloadContentScripts(changes.changedSteps, server);
            const rebuiltNames = changes.rebuildGroups.flat().map((entry) => entry.name);
            wxt.logger.success(`Reloaded: ${getFilenameList(rebuiltNames)}`);
            break;
        }
      } catch {
      }
    });
  };
  return debounce(cb, wxt.config.dev.server.watchDebounce, {
    leading: true,
    trailing: false
  });
}
function reloadContentScripts(steps, server) {
  if (wxt.config.manifestVersion === 3) {
    steps.forEach((step) => {
      if (server.currentOutput == null) return;
      const entry = step.entrypoints;
      if (Array.isArray(entry) || entry.type !== "content-script") return;
      const js = getContentScriptJs(wxt.config, entry);
      const cssMap = getContentScriptsCssMap(server.currentOutput, [entry]);
      const css = getContentScriptCssFiles([entry], cssMap);
      server.reloadContentScript({
        registration: entry.options.registration,
        contentScript: mapWxtOptionsToRegisteredContentScript(
          entry.options,
          js,
          css
        )
      });
    });
  } else {
    server.reloadExtension();
  }
}
function reloadHtmlPages(groups, server) {
  const htmlEntries = groups.flat().filter(isHtmlEntrypoint);
  htmlEntries.forEach((entry) => {
    const path = getEntrypointBundlePath(entry, wxt.config.outDir, ".html");
    server.reloadPage(path);
  });
  return {
    reloadedNames: htmlEntries.map((entry) => entry.name)
  };
}
function getFilenameList(names) {
  return names.map((name) => {
    return pc.cyan(name);
  }).join(pc.dim(", "));
}
function getExternalOutputDependencies(server) {
  return server.currentOutput?.steps.flatMap((step, i) => {
    if (Array.isArray(step.entrypoints) && i === 0) {
      return [];
    }
    return step.chunks.flatMap((chunk) => {
      if (chunk.type === "asset") return [];
      return chunk.moduleIds;
    });
  }).filter(
    (file) => !file.includes("node_modules") && !file.startsWith("\0")
  ).map(unnormalizePath).filter((file) => !file.startsWith(wxt.config.root)) ?? [];
}
